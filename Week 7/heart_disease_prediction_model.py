# -*- coding: utf-8 -*-
"""Heart Disease Prediction Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wx1oQzRbmPiBzL10gJ1-Nv0usd6pJCjM

# Heart Disease prediction
"""

!pip install gradio

# Commented out IPython magic to ensure Python compatibility.
#!pip install sklearm
# Importing all the libraries

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

#Inline matpotlib to view inside the notebook directly
# %matplotlib inline

# Models
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier

# Evaluation
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.model_selection import RandomizedSearchCV, GridSearchCV
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.metrics import precision_score, recall_score, f1_score
from sklearn.metrics import RocCurveDisplay

# Gradio dependencies
import gradio as gr
import joblib

from google.colab import files
uploaded = files.upload()

"""### Data cleaning and analysis"""

df = pd.read_csv("/content/heart.csv")
df.shape
df.head()
df.info()

df.head()

df.tail()

# how many class of one feature or target
df["target"].value_counts()

# Bar Chart
df["target"].value_counts().plot(kind='bar', color=["salmon", "lightblue"])

df.info()

df.isna().sum()

df.describe()

"""### Exploratory Data Analysis"""

# Checking for outliers in individual columns
for column in df.select_dtypes(include=['number']).columns:
    plt.figure(figsize=(10, 5))
    df.boxplot(column=column)
    plt.title(f'Box Plot of {column} (IQR Method)')
    plt.show()

# Dealing with outliers in the dataset
def remove_outliers_iqr(df, columns):
    for column in columns:
        Q1 = df[column].quantile(0.25)
        Q3 = df[column].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Filter out outliers
        df = df[(df['tresbts'] >= lower_bound) & (df['tresbts'] <= upper_bound)]
        df = df[(df['chol'] >= lower_bound) & (df['chol'] <= upper_bound)]
        df = df[(df['thalac'] >= lower_bound) & (df['thalac'] <= upper_bound)]
        df = df[(df['thalac'] >= lower_bound) & (df['thalac'] <= upper_bound)]
        df = df[(df['oldpeak'] >= lower_bound) & (df['oldpeak'] <= upper_bound)]
        df = df[(df['ca'] >= lower_bound) & (df['ca'] <= upper_bound)]
    return df

"""# Training the data"""

# Feature scaling
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
scaled_features = scaler.fit_transform(df.drop('target', axis=1))  # Assuming 'target' is the label
df_scaled = pd.DataFrame(scaled_features, columns=df.columns[:-1])
df_scaled['target'] = df['target']  # Re-attach the target column

# Split data into X and y for training features and target variable
X = df.drop("target", axis=1)
y = df["target"]

# Split dta into train and test sets
np.random.seed(42)
X_train,X_test,y_train,y_test = train_test_split(X, y,test_size=0.2)

# Train base models
models = {"Logistic Regression": LogisticRegression(),
          "KNN": KNeighborsClassifier(),
          "Random Forest": RandomForestClassifier()}

# Create function to fit and score models
def fit_and_score(models, X_train, X_test, y_train, y_test):
  # Set random seed
  np.random.seed(42)
  # Dictionary to keep the model scores
  model_scores = {}
  # Loop through the models
  for name, model in models.items():
    # Fit model
    model.fit(X_train, y_train)
    # Evaluate Model and append score
    model_scores[name] = model.score(X_test, y_test)
  return model_scores

model_scores = fit_and_score(models=models, X_train=X_train, X_test=X_test, y_train=y_train, y_test=y_test)
model_scores

model_compare = pd.DataFrame(model_scores, index=["accuracy"])
# Plotting the model scores
plt.figure(figsize=(10, 5))
model_compare.T.plot(kind='bar', color='skyblue')
plt.title('Model Accuracy Comparison')
plt.xlabel('Models')
plt.ylabel('Accuracy')
plt.xticks(rotation=45)
plt.ylim(0, 1)  # Set y-axis limit
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

"""# Gradient Boosting Model

**3**. Building the Gradient Boosting Model
"""

from sklearn.model_selection import train_test_split

# Define features and target
X = df_scaled
y = df['target']

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Initialize the model
gb_model = GradientBoostingClassifier()

# Train the model
gb_model.fit(X_train, y_train)

# Make predictions
y_pred = gb_model.predict(X_test)

# Evaluate the model
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
#Accuracy: How often is the model correct in its predictions?
#Precision: How often is the model correct when it predicts a positive case (heart disease)?
#Recall: How often does the model correctly identify positive cases?
#F1-score: A balance between precision and recall.

"""4. Hyperparameter Tuning"""

from sklearn.model_selection import GridSearchCV

# Define hyperparameter grid
param_grid = {
    'n_estimators': [100, 200, 300],
    'learning_rate': [0.01, 0.1, 0.2],
    'max_depth': [3, 4, 5],
}

# GridSearchCV for parameter tuning
grid_search = GridSearchCV(GradientBoostingClassifier(), param_grid, cv=5, scoring='accuracy', verbose=1)
grid_search.fit(X_train, y_train)

# Best parameters
print("Best Parameters:", grid_search.best_params_)

# Evaluate best model
best_model = grid_search.best_estimator_
y_pred_best = best_model.predict(X_test)
print("Tuned Model Accuracy:", accuracy_score(y_test, y_pred_best))

"""5. Deploying the Model"""

import joblib

# Save the model
joblib.dump(best_model, 'gradient_boosting_model.pkl')

# Load the model for future use
loaded_model = joblib.load('gradient_boosting_model.pkl')

"""### Deploying the model"""

def predict_heart_disease(age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal):

  # Create an array of the input features
  input_data = np.array([[age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal]])

  # Make the prediction
  prediction = loaded_model.predict(input_data)

  # Return the prediction
  if prediction[0] == 0:
    return "The person does not have heart disease"
  else:
    return "The person has heart disease"

def process_input(age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal):
    if sex == "Male":
        sex = 1
    else:
        sex = 0

    if fbs == ">120mg/dL":
        fbs = 1
    else:
        fbs = 0

    if cp == "Typical angina":
        cp = 0
    elif cp == "Atypical angina":
        cp = 1
    elif cp == "Non-anginal pain":
        cp = 2
    elif cp == "Asymptomatic":
        cp = 3

    if exang == "Exercise Induced angina":
        exang = 1
    else:
        exang = 0

    if slope == "Upsloping":
        slope = 0
    elif slope == "Flat":
        slope = 1
    elif slope == "Downsloping":
        slope = 2

    if thal == "Normal":
        thal = 0
    elif thal == "Fixed Defect":
        thal = 1
    else:
        thal = 2

    if restecg == "Normal":
        restecg = 0
    elif restecg == "ST-T Wave Abnormality":
        restecg = 1
    else:
        restecg = 2

    predicted_class = predict_heart_disease(age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal)
    print(predicted_class)
    return predicted_class

def create_gradio_ui():
        inputs = [
        gr.Number(label="Age"),
        gr.Radio(choices=["Male", "Female"], label="Sex", type="value"),
        gr.Radio(choices=["Typical angina","Atypical angina","Non-anginal pain","Asymtomatic"], label="Chest Pain", type="value"),
        gr.Number(label="Resting Blood Pressure"),
        gr.Number(label="Cholesterol"),
        gr.Radio(choices=["FBS > 120", "FBS <= 120"], label="Fasting Blood Sugar", type="value"),
        gr.Radio(choices=["Normal", "Having ST-T wave abnormality" ,"Showing probable or definite left ventricular hypertrophy by Estats' criteria"], label="Rest ECG", type="value"),
        gr.Number(label="Thalach"),
        gr.Radio(choices=["Yes ", "No"], label="Exercise induced angina ", type="value"),
        gr.Number(label="Old Peak "),
        gr.Radio(choices=["Upsloping", "Flat","Downsloping"], label="Slope of peak exercise ST segment ", type="value"),
        gr.Radio(choices=[0,1,2,3], label="Number of major vessels coloured by fluoroscopy", type="value"),
        gr.Radio(choices=["Normal","Fixed Defect","Reversible Defect"], label="Thalassemia", type="value"),
    ]

import numpy as np
import gradio as gr

# Dummy loaded model for demonstration purposes
# Replace with your actual model loading code
# Example: loaded_model = joblib.load("heart_disease_model.pkl")
class DummyModel:
    def predict(self, input_data):
        return [1]  # Always predicts "heart disease" for demonstration

loaded_model = DummyModel()

# Prediction function
def predict_heart_disease(age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal):
    # Create an array of the input features
    input_data = np.array([[age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal]])

    # Make the prediction
    prediction = loaded_model.predict(input_data)

    # Return the prediction
    if prediction[0] == 0:
        return "The person does not have heart disease"
    else:
        return "The person is at risk of having heart disease"

# Processing function for input data
def process_input(age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal):
    # Map categorical inputs to numerical values
    sex = 1 if sex == "Male" else 0
    fbs = 1 if fbs == "FBS > 120" else 0
    cp_mapping = {
        "Typical angina": 0,
        "Atypical angina": 1,
        "Non-anginal pain": 2,
        "Asymptomatic": 3
    }
    cp = cp_mapping[cp]
    exang = 1 if exang == "Yes" else 0
    slope_mapping = {"Upsloping": 0, "Flat": 1, "Downsloping": 2}
    slope = slope_mapping[slope]
    thal_mapping = {"Normal": 0, "Fixed Defect": 1, "Reversible Defect": 2}
    thal = thal_mapping[thal]
    restecg_mapping = {
        "Normal": 0,
        "Having ST-T wave abnormality": 1,
        "Showing probable or definite left ventricular hypertrophy by Estes' criteria": 2
    }
    restecg = restecg_mapping[restecg]

    # Call the prediction function
    predicted_class = predict_heart_disease(
        age, sex, cp, trestbps, chol, fbs, restecg, thalach, exang, oldpeak, slope, ca, thal
    )
    return predicted_class

# Function to create Gradio UI
def create_gradio_ui():
    return [
        gr.Number(label="Age"),
        gr.Radio(choices=["Male", "Female"], label="Sex", type="value"),
        gr.Radio(
            choices=["Typical angina", "Atypical angina", "Non-anginal pain", "Asymptomatic"],
            label="Chest Pain",
            type="value"
        ),
        gr.Number(label="Resting Blood Pressure"),
        gr.Number(label="Cholesterol"),
        gr.Radio(choices=["FBS > 120", "FBS <= 120"], label="Fasting Blood Sugar", type="value"),
        gr.Radio(
            choices=[
                "Normal",
                "Having ST-T wave abnormality",
                "Showing probable or definite left ventricular hypertrophy by Estes' criteria"
            ],
            label="Rest ECG",
            type="value"
        ),
        gr.Number(label="Thalach"),
        gr.Radio(choices=["Yes", "No"], label="Exercise induced angina", type="value"),
        gr.Number(label="Old Peak"),
        gr.Radio(choices=["Upsloping", "Flat", "Downsloping"], label="Slope of peak exercise ST segment", type="value"),
        gr.Radio(choices=[0, 1, 2, 3], label="Number of major vessels colored by fluoroscopy", type="value"),
        gr.Radio(choices=["Normal", "Fixed Defect", "Reversible Defect"], label="Thalassemia", type="value"),
    ]

# Main execution
if __name__ == "__main__":
    inputs = create_gradio_ui()  # Define inputs
    output = gr.Textbox(label="Prediction Result")  # Define output

    # Create Gradio interface
    interface = gr.Interface(
        fn=process_input,  # Function to process inputs
        inputs=inputs,     # Input widgets
        outputs=output     # Output widget
    )

    # Launch the Gradio interface
    interface.launch()